\chapter{Wstęp}

Rozpowszechnione algorytmy sztucznej inteligencji wspomagające pracę inżynierów dźwięku można podzielić na trzy główne kategorie~\cite{analysis_generative}~\label{traditional_algos}:

\begin{enumerate}
    \item algorytmy generujące symboliczny zapis muzyki (nuty lub dane MIDI) (\ref{fig:lamus_notes}),~\cite{zhang2023language},
    \item algorytmy generujące gotowy plik audio (\ref{fig:riffusion_spectro}).
    \item algorytmy symulujące brzmienie instrumentów muzycznych za pomocą sieci neuronowych~\cite{engel2017neural}.
\end{enumerate}

Pierwsza grupa algorytmów znana jest już od lat 80, gdyż zagadnienie generowania zapisu symbolicznego wymaga mniej mocy obliczeniowej niż wytworzenie pełnego pliku audio.
Powszechnie wykorzystywana jest w nich teoria muzyki, pozwalająca określić matematyczne relacje występujące w rytmach, melodiach i progresjach akordów.
Wiedza dotyczącą teorii muzyki pozwala na wyznaczenie możliwej przestrzeni stanów, w której generowana jest kompozycja,
natomiast modele matematyczne takie jak łańcuchy Markowa służą za mechanizmy decyzyjne, które~,,nawigują'' w przestrzeni stanów.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{rys01/lamus_notes.jpg}
    \caption{
      Zapis nutowy utworu \textit{Opus One},
      wygenerowany przez komputer \textit{Lamus}.
    }\label{fig:lamus_notes}
\end{figure}

Druga grupa algorytmów, generująca pliki audio, rozwija się na bazie nowych możliwości,
które zapewniają algorytmy wywodzące się ze \textit{Stable Diffusion}~\cite{stablediffusion}.
Najnowsze modele generujące pliki audio zgodne z opisem tekstowym 
(przykładowo \texttt{,,smutny jazz''} bądź \texttt{,,muzyka taneczna w stylu Depeche Mode''})
szkolone są w taki sam sposób jak algorytmy stable diffusion. 
Jednakże zamiast na obrazach artystów, modele takie jak \textit{Stable Riffusion}~\cite{riffusion} 
uczą się na spektrogramach, które następnie są w stanie wygenerować (\ref{fig:riffusion_spectro}).
Po wygenerowaniu spektrogramu przez model,
jest on konwertowany do pliku audio za pomocą odwrotnej transformaty Fouriera.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{rys01/riffusion_spectro.jpg}
    \caption{
      Przykładowy spektrogram wygenerowany przez algorytm \textit{Stable Riffusion}
      dla danych wejściowych \texttt{funk bassline with a jazzy saxophone solo}.
    }\label{fig:riffusion_spectro}
\end{figure}

% TODO: check later
% https://github.com/Kinyugo/msanii

Metody opisane w rozdziale~\ref{traditional_algos} można porównać pod względem ich przydatności
dla użytkownika końcowego, czyli osoby zajmującej się produkcją nagrań muzycznych. Metoda pierwsza, 
generowanie zapisu symbolicznego, może wydawać się mniej zaawansowana niż generowanie całych plików dźwiękowych.
Jednakże, z perspektywy użytkownika, zapis symboliczny jest bardziej praktyczny,
ponieważ możliwe jest zaimportowanie go do programu DAW i późniejsza modyfikacja zapisu nutowego.
Obecnie dostępne modele generujące pełne nagrania z muzyką nie umożliwiają
szczegółowego edytowania parametrów wygenerowanego dźwięku, ponieważ operują bardzo wysokopoziomowo 
-- syntezują muzykę na podstawie opisu słownego.

Podsumowując, wykorzystanie wygenerowanego przez komputer zapisu nutowego jest proste, ze względu na symboliczną naturę zapisu.
Wykorzystanie wygenerowanego przez komputer \textbf{dźwięku} jest ograniczone ze względu na fakt, że do generowania złożonych sygnałów dźwiękowych wykorzystywane są techniki takie jak głębokie sieci neuronowe, w których utrudniona jest dokładna kontrola nad konkretnymi parametrami funkcjonowania sieci.

Niniejsza praca sugeruje nową metodę podejścia do problemu generowania sygnałów dźwiękowych,
którego nie da się zaklasyfikować do żadnej z dwóch wyżej wymienionych~(\ref{traditional_algos}) głównych dziedzin komputerowej kompozycji muzycznej.
Wynik pracy algorytmu implementowanego w ramach pracy magisterskiej jest \textbf{gotowym elektronicznym
instrumentem muzycznym}, który może być wykorzystany w programie do komponowania muzyki. Algorytm nie generuje bezpośrednio sygnału dźwiękowego, lecz tworzy graf przetwarzania sygnałów, który jest zrozumiały dla użytkownika i \textbf{pozwala na precyzyjne dostosowanie parametrów syntezy}.
Tego typu proces generowania grafów przetwarzania sygnałów dźwiękowych może być porównany z procesem projektowania instrumentu muzycznego.

Modyfikowanie grafu przetwarzania sygnału jest techniką często wykorzystywaną w muzyce
elektronicznej, do tworzenia dźwięków o interesującej barwie bądź dynamice. Syntezatory dźwięku
dostępne na rynku często wyposażone są w \textit{patch bay}~(\ref{fig:mother32}), pozwalający na modyfikowanie
grafu przepływu sygnałów wewnątrz syntezatora, bądź połączenie go z zewnętrznym sprzętem muzycznym
bądź elektronicznym.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{rys01/mother32.jpg}
    \caption{
      Syntezator \textit{Mother 32} firmy \textit{Moog}, po prawej stronie widoczny
      jest \textit{patch bay} z podłączonymi przewodami, które nadpisują konfigurację
      połączeń między układami generującymi i przetwarzającymi sygnał dźwiękowy.
    }\label{fig:mother32}
\end{figure}


\section{Cel pracy}


Celem pracy jest zbadanie, czy algorytmy optymalizacyjne są w stanie
wytworzyć graf przetwarzania sygnałów audio, który wykona syntezę próbki
dźwięku zadanej przez użytkownika.
Problem poruszany w pracy można zakwalifikować do grupy zagadnień związanych
z pojęciami \textit{computer-aided design} oraz \textit{generative artificial intelligence}, zastosowanymi w dziedzienie inżynierii dźwięku. Docelowo
zaimplementowany algorytm będzie automatyzował pracę inżyniera dźwięku,
tworząc i konfigurując grafy przetwarzania sygnałów dźwiękowych, dostępne w
programach typu \textit{digital audio workstation}~(\ref{fig:ableton_patch}). Badania obejmują dwa zagadnienia:
\textbf{
\begin{enumerate}\label{research_types}
    \item metody generowania grafu przetwarzania sygnałów oraz późniejszej modyfikacji grafu -- jego struktury oraz parametrów,
    \item dobór funkcji celu, na podstawie której algorytm optymalizujący będzie modyfikował graf przetwarzania sygnałów.
\end{enumerate}
}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{rys01/ableton_patch.jpg}
    \caption{
      Zbiór parametrów konfigurujących przykładowy syntezator dźwięku w programie \textit{Ableton}
    }\label{fig:ableton_patch}
\end{figure}

\subsection{Generowanie grafu przetwarzania sygnałów}

Proces syntezy dźwięku może być przedstawiony jako graf przetwarzania sygnałów, w którym
każdy węzeł wykonuje na sygnale określoną operację.
Przykładowy graf przetwarzania sygnału dla syntezatora analogowego subtraktywnego
przedstawiony jest na schemacie~\ref{fig:minilogue_diagram}.
Pierwsze zagadnienie sprowadza się do opracowania algorytmu pozwalającego na wygenerowanie
grafu przetwarzania sygnałów DSP oraz jego późniejszą modyfikację. Przykładem modyfikacji grafu
może być wprowadzanie w nim losowych zmian lub krzyżowanie dwóch różnych grafów DSP\@.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{rys01/minilogue_voice_block_diagram.png}
    \caption{
      Diagram blokowy pojedynczego głosu w syntezatorze 
      \textit{Minilogue xd} firmy \textit{Korg}~\cite{minilogue_diagram}.
    }\label{fig:minilogue_diagram}
\end{figure}

\subsection{Funkcja celu oceniająca podobieństwo barwy dźwieku}

Drugie zagadnienie obejmuje przetestowanie szeregu algorytmów, które można
wykorzystać do zbudowania funkcji celu, która będzie optymalizowana
poprzez~,,dostrajanie'' parametrów i struktury grafu przetwarzania sygnałów dźwiękowych.
% todo: więcej o funkcji celu

Praca proponuje wykorzystanie [
  \textbf{Tutaj propozycja jak już się przekręcą wszystkie symulacje}
] jako funkcji celu.

\subsection{Problem optymalizacyjny}

Następnie, dla danego układu $N$ węzłów przetwarzania oraz dla macierzy połączeń $C$, 
należy rozwiązać następujący problem optymalizacji, należy rozwiązać problem
maksymalizacji funkcji opisanej równaniem~\ref{eq:target_function} dla
parametrów wszystkich wejść $i_j$ oraz $o_j$, które nie są połączone bezpośrednio
pomiędzy węzłami.




\section{Zakres pracy, plan badań}

\subsection{Metody generowania grafu przetwarzania sygnałów oraz późniejsza modyfikacja grafu}

Głównym problemem przy generowaniu grafu przetwarzania sygnałów są ograniczenia nałożone na strukturę grafu,
które należy spełnić, by graf był logicznie interpretowalny jako łańcuch przetwarzania sygnałów.
Graf musi być grafem skierowanym, który nie zawiera pętli o dodatnim sprzężeniu zwrotnym 
(lub nie zawiera ich wcale, co można założyć dla uproszczenia problemu).
Struktura grafu powinna być możliwie jak najbardziej przejrzysta dla użytkownika. 
Automatyczna ewolucja może dążyć w kierunku wykorzystania nadmiarowej liczby
bloków przetwarzania sygnału, jeśli funkcja celu nie będzie zawierała kary za zbyt złożone grafy.
Podobne prace~\cite{evolutionary_puredata} wykorzystują podejście oparte o 
\textit{mixed-typed carthesian genetic programming}, które będzie punktem startowym dla pracy.
Finalnie, badania dążą do wyznaczenia algorytmu o następujący właściwościach:

\begin{enumerate}
    \item algorytm generuje grafy będące logicznie spójnymi łańcuchami przetwarzania dźwięku (skierowany, bez pętli o dodatnim sprzężeniu zwrotnym w natężeniu sygnału),
    \item algorytm maksymalizuje wykorzystanie poszczególnych bloków przetwarzania w grafie, co minimalizuje finalny rozmiar grafu, czyniąc go bardziej czytelnym,
    \item generowany graf posiada reprezentację umożliwiającą wykonanie krzyżowania dwóch grafów przetwarzania sygnału. Graf będący wynikiem krzyżowania nadal musi być poprawnym grafem przetwarzania sygnału.
\end{enumerate}

Elementami grafu przetwarzania sygnałów są używane powszechnie w syntezie dźwięku algorytmy:

\begin{enumerate}
  \item modulacja FM~\cite{spectral_audio_processing}~\cite{computational_music_synthesis},
  \item synteza subtraktywna~\cite{computational_music_synthesis}~\cite{digital_filters},
  \item algorytmy \textit{physical modeling}~\cite{lisp_synthesis}~\cite{computational_music_synthesis},
  \item symulacja efektu pogłosu/echa~\cite{reverb}~\cite{freeverb}.
\end{enumerate}

\subsection{Dobór funkcji błędu: różnica między wygenerowanym a docelowym sygnałem dźwiękowym}

Funkcja celu poszukiwana w ramach projektu musi określać, jak dobrze sygnał wygenerowany przez
graf przetwarzania sygnałów pokrywa się z sygnałem docelowym. Porówanie sygnałów musi skupiać się
na cechach sygnału, które są najbardziej słyszalne dla ludzkiego ucha. Jednocześnie funkcja nie powinna
,,karać'' sygnałów, które są względem siebie przesunięte w fazie. Wśród algorytmów, które zostały wybrane
do przetestowania w ramach projektów zawarte są:

\begin{enumerate}
  \item algorytmy porównywania sygnałów oparte o transformatę Fouriera~\cite{sliding_fourier}~\cite{mfcc},
  \item techniki wykorzystywane do generowania~,,cyfrowych podpisów'' sygnałów dźwiękowych (\textit{sound fingerprinting})~\cite{computer_vision_music_identification},
  \item algorytmy wykrywające spadek jakości dźwięku z perspektywy psychoakustycznej~\cite{peaq}~\cite{frechet_audio_distance}.
\end{enumerate}

\section{Struktura i zawartość pracy}

Praca podzielona jest na następujące części:

\subsection*{Definicja problemu (\ref{chap:problem_definition})}

Formalizuje i opisuje problem optymalizacyjny rozwiązywany w pracy.

\subsection*{Analiza i wybór funkcji celu (\ref{target_function_chapter}) }

Porównuje funkcje z dziedziny przetwarzania sygnałów, które pozwalają określić jak podobna jest barwa dźwięku dwóch sygnałów dźwiękowych.
Uzasadnia wybór funkcji celu, która została zastosowana w pracy.

\subsection*{Algorytm rozwiązania (\ref{chap:solution_algorithm})}

Opisuje algorytm wykorzystany do rozwiązania problemu
zdefiniowanego w rozdziale~\ref{chap:problem_definition}.

\subsection*{Środowisko eksperymentalne: graf przetwarzania sygnałów (\ref{dsp_graph_chapter}) }

Opisuje zaimplementowane w ramach pracy środowisko eksperymentalne, pozwalające na wytwarzanie
grafów przetwarzania sygnałów o dowolnej strukturze. Przedstawia zaimplementowane algorytmy syntezy i przetwarzania sygnałów dźwiękowych.


\subsection*{Optymalizacja struktury grafu DSP oraz jego parametrów (\ref{chap:research}) }

Opisuje proces badawczy, w którym narzędzia wytworzone w rozdziałach~\ref{dsp_graph_chapter} oraz~\ref{target_function_chapter}
zostały wykorzystane do automatycznego wytworzenia grafu DSP, który naśladuje barwę zadanej próbki dźwięku.

\subsection*{Analiza wyników, dyskusja nad skutecznością działania algorytmu oraz możliwe drogi dalszego rozwoju (\ref{results_analysis_chapter})}

Rozdział podsumowuje uzyskane wyniki badań, podejmuje dyskusję nad ogólną skutecznością i przydatnością zaimplementowanego rozwiązania oraz
kreśli potencjalne drogi dalszego rozwoju prac badawczych w podobnej tematyce. W czasie, gdy niniejsza praca była tworzona, zostały opublikowane badania
dotyczące podobnego problemu~\cite{ieee_synth_programming}, rozdział podejmuje dyskusję o różnicach w podejściu do problemu oraz potencjalnych
zalet i wad każdego z podejść.

